using System;
using System.CodeDom;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml.Schema;
using System.Xml;
using System.Web.Services.Description;

namespace Ws.SvcUtilCodeGen
{

    /// <summary>
    /// Enum defines the support target runtime platforms supported by the code generator.
    /// </summary>
    public enum TargetPlatform
    {
        MicroFramework,
        Win32
    }

    internal enum MessageType
    {
        Request,
        Response
    }
    
    internal enum MessageEncodingType
    {
        Soap,
        Mtom
    }
    
    /// <summary>
    /// Helper method used to get a header used in auto generated files.
    /// </summary>
    internal static class AutoGenTextHeader
    {
        private static string m_message =
           "//------------------------------------------------------------------------------\r\n" +
           "// <auto-generated>\r\n" +
           "//     This code was generated by a tool.\r\n" +
           "//     .NET Micro Framework MFSvcUtil.Exe\r\n" +
           "//     Runtime Version:2.0.00001.0001\r\n" +
           "//\r\n" +
           "//     Changes to this file may cause incorrect behavior and will be lost if\r\n" +
           "//     the code is regenerated.\r\n" +
           "// </auto-generated>\r\n" +
           "//------------------------------------------------------------------------------\r\n" +
           "\r\n\r\n";

        /// <summary>
        /// Gets the preset csharp source file header message
        /// </summary>
        /// <returns></returns>
        public static string Message { get { return m_message; } }

        /// <summary>
        /// Get the length of the preset header message
        /// </summary>
        public static int Length { get { return m_message.Length; } }
    }

    /// <summary>
    /// A wsdl policy assertion object
    /// </summary>
    public class PolicyAssertion
    {
        public readonly Uri Namespace;
        public readonly string Name = "";
        public readonly string PolicyID = "";
        public PolicyAssertion(string name, Uri namespaceUri, string policyID)
        {
            if (name == null)
                throw new ArgumentNullException("Policy Assertion name must not be null.");
            if (namespaceUri == null)
                throw new ArgumentNullException("Policy Assertion namespace uri must not be null.");
            if (policyID == null)
                throw new ArgumentNullException("Policy Assertion policy ID must not be null.");
            Name = name;
            Namespace = namespaceUri;
            PolicyID = policyID;
        }
    }

    /// <summary>
    /// Common helper methods used by all code gen classes.
    /// </summary>
    internal static class CodeGenUtils
    {
        /// <summary>
        /// Finds a schema element by name in the current schema set.
        /// </summary>
        /// <param name="elementName">The name of an element to search for.</param>
        /// <param name="elementNs">The elements namespace uri.</param>
        /// <returns>An XmlAchemaElement containing the specified element or nul if not found.</returns>
        internal static XmlSchemaElement FindSchemaElement(ServiceDescription svcDesc, string elementName, string elementNs)
        {
            // Find the element used in the message
            foreach (XmlSchema schema in svcDesc.Types.Schemas)
            {
                // For each item in the schema find the matching message element or type \
                // for the current operation
                foreach (object item in schema.Items)
                {
                    if (item.GetType() == typeof(XmlSchemaElement))
                    {
                        if (((XmlSchemaElement)item).QualifiedName.Name == elementName && ((XmlSchemaElement)item).QualifiedName.Namespace == elementNs)
                            return (XmlSchemaElement)item;
                    }
                }
            }
            return null;
        }

        internal static bool IsSoapBinding(PortType portType, ServiceDescription servDesc)
        {
            if (portType.ServiceDescription.Bindings != null && portType.ServiceDescription.Bindings.Count > 0)
            {
                foreach (Binding binding in portType.ServiceDescription.Bindings)
                {
                    // Make sure this is the right binding
                    if (binding.Type.Name == portType.Name)
                    {
                        // If this is the soap12 binding set the style and break;
                        if (binding.Extensions.Find(typeof(Soap12Binding)) != null ||
                            binding.Extensions.Find(typeof(SoapBinding)) != null)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Determines if this operations message is Document/Literal
        /// </summary>
        /// <param name="operation">An OperationMessage object containing the operation to check.</param>
        /// <returns>True if the binding style="document" and soap12Binding operaiton use="literal" else false.</returns>
        internal static bool IsDocumentLiteral(OperationMessage operationMessage)
        {
            bool docStyle = true;
            Binding soapBinding = null;
            if (operationMessage.Operation.PortType.ServiceDescription.Bindings != null)
            {
                foreach (Binding binding in operationMessage.Operation.PortType.ServiceDescription.Bindings)
                {
                    // Make sure this is the right binding
                    if (binding.Type.Name == operationMessage.Operation.PortType.Name)
                    {

                        // If this is the soap12 binding set the style and break;
                        if (binding.Extensions.Find(typeof(Soap12Binding)) != null)
                        {
                            soapBinding = binding;
                            for (int i = 0; i < soapBinding.Extensions.Count; ++i)
                            {
                                if (soapBinding.Extensions[i] is Soap12Binding)
                                    if (((Soap12Binding)soapBinding.Extensions[i]).Style == SoapBindingStyle.Rpc)
                                        docStyle = false;
                            }
                            break;
                        }
                    }
                }
                if (soapBinding != null)
                {
                    foreach (OperationBinding operationBinding in soapBinding.Operations)
                        if (operationBinding.Name == operationMessage.Operation.Name)
                        {
                            Soap12BodyBinding soapBodyBinding;
                            if (operationMessage is OperationInput)
                            {
                                soapBodyBinding = (Soap12BodyBinding)operationBinding.Input.Extensions.Find(typeof(Soap12BodyBinding));
                            }
                            else
                                soapBodyBinding = (Soap12BodyBinding)operationBinding.Output.Extensions.Find(typeof(Soap12BodyBinding));

                            if (soapBodyBinding != null)
                            {
                                // Since no one uses use="encoded" anymore throw else use="literal"
                                if (soapBodyBinding.Use == SoapBindingUse.Encoded)
                                    throw new XmlException("Invalid operation binding use \"encoded\" is not supported. Operation Name = " + operationMessage.Name);
                                return docStyle;
                            }
                        }
                }
                Logger.WriteLine("No wsdl Soap12Binding detected. Assuming style=\"document\" use=\"literal\"", LogLevel.Normal);
                return true;
            }
            Logger.WriteLine("No wsdl binding section detected. Assuming style=\"document\" use=\"literal\"", LogLevel.Normal);
            return true;
        }

        /// <summary>
        /// Determines if this operations message is Document/Literal
        /// </summary>
        /// <param name="operation">An OperationMessage object containing the operation to check.</param>
        /// <returns>
        /// A string containing the namespace defined by the binding/operation/soap12Body/namespace attribute
        /// if found else the target namespace is assumed.
        /// </returns>
        internal static string GetOperationNamespace(OperationMessage operationMessage)
        {
            string operationNs = null;
            Binding soapBinding = null;
            if (operationMessage.Operation.PortType.ServiceDescription.Bindings != null)
            {
                foreach (Binding binding in operationMessage.Operation.PortType.ServiceDescription.Bindings)
                {
                    // If this is the soap12 binding set the style and break;
                    if (binding.Extensions.Find(typeof(Soap12Binding)) != null)
                    {
                        soapBinding = binding;
                        break;
                    }
                }
                if (soapBinding != null)
                {
                    foreach (OperationBinding operationBinding in soapBinding.Operations)
                        if (operationBinding.Name == operationMessage.Operation.Name)
                        {
                            Soap12BodyBinding soapBodyBinding;
                            if (operationMessage is OperationInput)
                            {
                                soapBodyBinding = (Soap12BodyBinding)operationBinding.Input.Extensions.Find(typeof(Soap12BodyBinding));
                            }
                            else
                                soapBodyBinding = (Soap12BodyBinding)operationBinding.Output.Extensions.Find(typeof(Soap12BodyBinding));

                            if (soapBodyBinding != null)
                            {
                                operationNs = soapBodyBinding.Namespace;
                                break;
                            }
                        }
                }
            }
            return operationNs == "" ? operationMessage.Operation.PortType.ServiceDescription.TargetNamespace : operationNs;
        }

        /// <summary>
        /// Used to determine if document/literal type is wrapped
        /// </summary>
        /// <param name="messagePart">A message part to check for wrapped style.</param>
        /// <returns>True if the first message parts name is "parameter".</returns>
        /// <remarks>
        /// Wrapped is only valid for document/literal since rpc/literal is always wrapped. Wrapped means a message
        /// must contain a single part that points to a complex element that contains the soap/body content.
        /// The name "parameter" used to identify wrapped type is defined by Microsoft but used by other. This will
        /// have to do until WS-I defines somethinf different.
        /// </remarks>
        internal static bool IsWrapped(MessagePart messagePart)
        {
            // If theres no messages this cant be wrapped
            if (messagePart == null)
                return false;

            return messagePart.Name == "parameters" ? true : false;
        }
        
        /// <summary>
        /// Finds a schema type by name from the collectino of service description schema types.
        /// </summary>
        /// <param name="typeName">A string containing a schema type name.</param>
        /// <returns>An XmlSchemaType object containing the specified schema type or null if not found.</returns>
        internal static XmlSchemaType FindSchemaType(ServiceDescription svcDesc, string typeName, string typeNamespace)
        {
            // Find the element used in the message
            foreach (XmlSchema schema in svcDesc.Types.Schemas)
            {
                // For each item in the schema find the matching message element or type
                // for the current operation
                foreach (object item in schema.Items)
                {
                    if (item.GetType() == typeof(XmlSchemaSimpleType) || item.GetType() == typeof(XmlSchemaComplexType))
                    {
                        if (((XmlSchemaType)item).QualifiedName.Name == typeName && ((XmlSchemaType)item).QualifiedName.Namespace == typeNamespace)
                            return (XmlSchemaType)item;
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// Maps xmlschema types to an appropriate Clr xml type converter method.
        /// </summary>
        /// <param name="typeName">A string containing a xml schema type name.</param>
        /// <returns>A string containing the converter method name.</returns>
        /// <remarks>
        /// Mapping follows .net Wcf DataContract mapping rules.
        /// </remarks>
        internal static string GetConvertMethod(string typeName)
        {
            switch (typeName.Substring(typeName.IndexOf('.') + 1))
            {
                case "Boolean":
                    return "ToBoolean";
                case "Byte":
                    return "ToByte";
                case "SByte":
                    return "ToSByte";
                case "Char":
                    return "ToChar";
                case "DateTime":
                    return "ToDateTime";
                case "TimeSpan":
                    return "ToTimeSpan";
                case "Decimal":
                    return "ToString"; // Until the MF-CLR supports decimal
                case "Double":
                    return "ToDouble";
                case "Single":
                    return "ToSingle";
                case "int":
                    return "ToInt32";
                case "Int16":
                    return "ToInt16";
                case "Int32":
                    return "ToInt32";
                case "Int64":
                    return "ToInt64";
                case "UInt16":
                    return "ToUInt16";
                case "UInt32":
                    return "ToUInt32";
                case "UInt64":
                    return "ToUInt64";
                case "Uri":
                    return "ToString";
                default:
                    return "ToString";
            }
        }

        /// <summary>
        /// Gets the value of a specified member attribute in a attribute collection.
        /// </summary>
        /// <param name="argumentName">A string containing the name of an argument to search for.</param>
        /// <param name="attributes">A collection of attributes to search.</param>
        /// <returns>A string containig the value of the attribute if found, else null.</returns>
        internal static string GetCustomAttributeArgumentValue(string argumentName, CodeAttributeDeclarationCollection attributes)
        {
            foreach (CodeAttributeDeclaration attribute in attributes)
            {
                if (attribute.Name == "DataContract" || attribute.Name == "DataMember" || attribute.Name == "EnumMember")
                {
                    for (int i = 0; i < attribute.Arguments.Count; ++i)
                        if (attribute.Arguments[i].Name == argumentName)
                            return (string)(((CodePrimitiveExpression)attribute.Arguments[i].Value).Value).ToString();
                }
            }
            return null;
        }

        /// <summary>
        /// Cobble up a valid .net namespace. Turn any progression that's not a-z or A-Z to a single '.'
        /// </summary>
        /// <param name="uriNamespace">URI namespace.</param>
        /// <returns>A string contianing t dot net formated namespace.</returns>
        internal static string GenerateDotNetNamespace(string uriNamespace)
        {
            int startNsIndex = uriNamespace.IndexOf("http://");
            startNsIndex = startNsIndex == 0 ? 7 : uriNamespace.IndexOf("urn:uuid:");
            startNsIndex = startNsIndex == 0 ? 9 : startNsIndex;
            startNsIndex = startNsIndex == -1 ? 0 : startNsIndex;
            string tns = uriNamespace.Substring(startNsIndex);
            byte[] codeNs = Encoding.UTF8.GetBytes(tns);
            int ii = 0;
            int lastHitIndex = 0;
            for (int i = 0; i < codeNs.Length; ++i, ++ii)
            {
                if ((codeNs[i] < 'a' || codeNs[i] > 'z') && (codeNs[i] < 'A' || codeNs[i] > 'Z'))
                {
                    ii = lastHitIndex == ii - 1 ? ii - 1 : ii;
                    lastHitIndex = ii;
                    codeNs[ii] = (byte)' ';
                }
                else
                    codeNs[ii] = codeNs[i];
            }

            string[] codeNss = Encoding.UTF8.GetString(codeNs).Substring(0, ii).Split(' ');
            string dotNetNamespace = codeNss[0];
            for (int i = 1; i < codeNss.Length; ++i)
                if (codeNss[i] != "")
                    if (dotNetNamespace == "")
                        dotNetNamespace += codeNss[i];
                    else
                        dotNetNamespace += "." + codeNss[i];
                return dotNetNamespace;
        }

        /// <summary>
        /// Gets a specific type (data contract) from a namespace.
        /// </summary>
        /// <param name="typeName">The name of a type (data contract) to search for.</param>
        /// <param name="codeNs">The CodeNamespace to search in.</param>
        /// <returns>A CodeTypeDeclaration containing the type (data contract), else nnull if not found.</returns>
        internal static CodeTypeDeclaration GetCodeType(string typeName, CodeNamespace codeNs)
        {
            foreach (CodeTypeDeclaration codeType in codeNs.Types)
                if (codeType.Name == typeName)
                    return codeType;
            return null;
        }

        /// <summary>
        /// Gets the DotNetNamespace for a given typename
        /// </summary>
        /// <param name="codeNamespaces">The CodeNamespace collection to search in.</param>
        /// <param name="typeName">The name of a type (data contract) to search for.</param>
        /// <returns>The DotNetNamespace for the given type if found, otherwise an empty string.</returns>
        internal static string GetNamespaceFromType(CodeNamespaceCollection codeNamespaces, string typeName)
        {
            // strip off the namespace
            int idx = typeName.LastIndexOf(".");
            string ns = "";

            if(idx >= 0)
            {
                ns = typeName.Substring(0, idx);
                
                typeName = typeName.Remove(0, idx+1);
            }
            
            // Search for the namespace
            foreach (CodeNamespace codeNs in codeNamespaces)
            {
                if(codeNs.Name == ns || ns == "")
                {
                    foreach(CodeTypeDeclaration ctd in codeNs.Types)
                    {
                        if(ctd.Name == typeName)
                        {
                            if(s_namespaceToDotNetNamespace.ContainsKey(codeNs))
                            {
                                return s_namespaceToDotNetNamespace[codeNs];
                            }
                            else
                            {
                                return "";
                            }
                        }
                    }
                }
            }
            
            return "";
        }

        ///
        /// Map between CodeNamespace and the DotNetNamespace
        ///
        static Dictionary<CodeNamespace, string> s_namespaceToDotNetNamespace = new Dictionary<CodeNamespace, string>();

        /// <summary>
        /// Used when adding a new type to a code namespace. Method looks for a matching namespace
        /// in the namespaces collection or adds a new one if it does not exist.
        /// </summary>
        /// <param name="codeNamespaces">A collection of code namespaces.</param>
        /// <param name="namespaceName">A string containig the name of the namespace to find or add.</param>
        /// <returns>A code namespace object containing a new code namespace or an existing namespace.</returns>
        internal static CodeNamespace GetDotNetNamespace(CodeNamespaceCollection codeNamespaces, string namespaceName)
        {
            CodeNamespace dotNetNamespace = null;
            string dotNetNamespaceName = GenerateDotNetNamespace(namespaceName);

            // Search for the namespace
            foreach (CodeNamespace codeNs in codeNamespaces)
            {
                if (codeNs.Name == dotNetNamespaceName)
                    return codeNs;
            }

            // If namespace was not found create on and add it to the namespaces collection
            dotNetNamespace = new CodeNamespace(dotNetNamespaceName);
            codeNamespaces.Add(dotNetNamespace);

            s_namespaceToDotNetNamespace[dotNetNamespace] = namespaceName;

            return dotNetNamespace;
        }
        
        /// <summary>
        /// Given a Wsdl Message part element returns the name of the request or response element
        /// wrapper. If a message part is not found return the name of the action with "Request" or "Response"
        /// appended.
        /// </summary>
        /// <param name="message">A Wsdl Message element.</param>
        /// <returns>The name of the Clr type used by the message element.</returns>
        internal static string GetMessageElementName(ServiceDescription svcDesc, Message message)
        {

            // If there is no message part(s) the message is void so return null
            if (message.Parts.Count == 0)
                return null;

            // If the message part contains a type reference
            XmlSchemaType type = null;
            string typeName = null;
            if (message.Parts[0].Element == null || message.Parts[0].Element.IsEmpty)
            {
                type = FindSchemaType(svcDesc, message.Parts[0].Type.Name, message.Parts[0].Type.Namespace);
                if (type.TypeCode == XmlTypeCode.None)
                    return message.Parts[0].Type.Name;
                typeName = message.Parts[0].Type.Name;
            }
            // If the message part contains an element reference
            else
            {
                XmlSchemaElement element = FindSchemaElement(svcDesc, message.Parts[0].Element.Name, message.Parts[0].Element.Namespace);
                if (element == null || element.SchemaTypeName == null || element.SchemaTypeName.Name == "")
                    return message.Parts[0].Element.Name;

                type = element.ElementSchemaType;
                typeName = message.Parts[0].Element.Name;
            }

            string clrTypeName = CodeGenUtils.GetClrType(typeName);
            clrTypeName = clrTypeName != null && clrTypeName.IndexOf("System.") == 0 ? clrTypeName.Substring(7) : clrTypeName;
            return clrTypeName == null ? typeName : clrTypeName;
        }

        /// <summary>
        /// Given a Wsdl Message part element returns the type refered to by the message part.
        /// </summary>
        /// <param name="message">A Wsdl Message element.</param>
        /// <returns>The name of the type used by the message element.</returns>
        internal static string GetMessageTypeName(ServiceDescription svcDesc, Message message)
        {

            // If there are no message part(s) the message is void so return null
            if (message.Parts.Count == 0)
                return null;

            // If the message contains a type reference instead of an element reference find the schema type
            XmlSchemaType type = null;
            string typeName = null;
            string elementName = null;
            if (message.Parts[0].Element == null || message.Parts[0].Element.IsEmpty)
            {
                type = FindSchemaType(svcDesc, message.Parts[0].Type.Name, message.Parts[0].Type.Namespace);
                if (type == null || type.TypeCode == XmlTypeCode.None)
                    return message.Parts[0].Type.Name;
                typeName = message.Parts[0].Type.Name;
            }
            else
            {
                XmlSchemaElement element = FindSchemaElement(svcDesc, message.Parts[0].Element.Name, message.Parts[0].Element.Namespace);
                if (element == null || element.SchemaTypeName == null || element.SchemaTypeName.Name == "")
                    return message.Parts[0].Element.Name;

                elementName = element.QualifiedName.Name;
                type = element.ElementSchemaType;
                typeName = element.SchemaTypeName.Name;
            }

            // If this is a complex type return the element type name
            if (type is XmlSchemaComplexType)
                return elementName == null ? type.Name : elementName;

            bool IsEnum = false;
            if (type.DerivedBy == XmlSchemaDerivationMethod.Restriction)
            {
                XmlSchemaSimpleTypeRestriction restriction = (XmlSchemaSimpleTypeRestriction)((XmlSchemaSimpleType)type).Content;
                foreach (XmlSchemaFacet facet in restriction.Facets)
                {
                    if (facet is XmlSchemaEnumerationFacet)
                    {
                        IsEnum = true;
                        break;
                    }
                }
            }

            // If this is a simple type with enumeration restrictions, return the type name.
            // Else return the clr type name if this is a native type or the simple type name if this is not a native type.
            if (IsEnum == true)
                return typeName;
            else
            {
                string clrTypeName = CodeGenUtils.GetClrType(type.TypeCode);
                clrTypeName = clrTypeName != null && clrTypeName.IndexOf("System.") == 0 ? clrTypeName.Substring(7) : clrTypeName;
                if (clrTypeName == null)
                    return typeName;
                else if (type.Datatype.ValueType.IsArray)
                {
                    string typeSuffix = (clrTypeName.Length > 2 && clrTypeName.Substring(clrTypeName.Length - 2) == "[]") ? "" : "[]";
                    return clrTypeName + typeSuffix;
                }
                else
                    return clrTypeName;
            }
        }

        /// <summary>
        /// Helper method used by hosted service and client proxy generators to generate
        /// a DataContractSerializer name.
        /// </summary>
        /// <param name="typeName">A string containing a DataContract type name.</param>
        /// <returns>A string contianing the generated name.</returns>
        /// <remarks>
        /// If this type is an array the "[]" brackets are replace with the text"Array". This is
        /// special method used to generate names used to support native type array serializers.
        /// </remarks>
        internal static string GenerateDcsName(string typeName)
        {
            string serializerName = typeName;
            if (typeName.Length > 2 && typeName.Substring(typeName.Length - 2) == "[]")
                serializerName = typeName.Substring(0, typeName.Length - 2) + "Array";
            return serializerName + "DataContractSerializer";
        }

        /// <summary>
        /// Determines if the element name is a C# intrinsic type name
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        internal static bool IsIntrinsicName(string name)
        {
            switch (name)
            {
                case "byte":
                case "sbyte":
                case "int":
                case "uint":
                case "short":
                case "ushort":
                case "long":
                case "ulong":
                case "float":
                case "double":
                case "char":
                case "bool":
                case "object":
                case "string":
                case "decimal":
                    return true;
            }
            return false;
        }
 

        /// <summary>
        /// Maps an xml schema type to a .net Clr type.
        /// </summary>
        /// <param name="schemaTypeName">An string containing the name of an XmlSchema type.</param>
        /// <returns>A string containing the mapped Clr type or null if a mapping does not exists.</returns>
        /// <remarks>
        /// This method maps schema types to clr types according to the wcf datacontract speficications.
        /// If a type is not supported by the .net micro clr is is mapped to a clr string type.
        /// </remarks>
        internal static string GetClrType(string schemaTypeName)
        {

            switch (schemaTypeName)
            {
                case "integer":
                    return "System.String"; // Until the MF-CLR supports Decimal
                case "boolean":
                    return "System.Boolean";
                case "string":
                    return "System.String";
                case "any":
                    return "XmlElement"; // Drop namesapce qualifier to solve MF-CLR type extension namespace inconsistencies
                case "anyAttribute":
                    return "XmlAttribute";    // Drop namesapce qualifier to solve MF-CLR type extension namespace inconsistencies
                case "anyType":
                    return "System.Object";
                case "anySimpleType":
                    return "System.String";
                case "AnyAtomicType":
                    return "object";
                case "duration":
                    return "System.TimeSpan";
                case "dateTime":
                    return "System.DateTime";
                case "time":
                    return "System.String";
                case "date":
                    return "System.String";
                case "gYearMonth":
                    return "System.String";
                case "gYear":
                    return "System.String";
                case "gMonthDay":
                    return "System.String";
                case "gDay":
                    return "System.String";
                case "gMonth":
                    return "System.String";
                case "base64Binary":
                    return "System.Byte[]";
                case "hexBinary":
                    return "System.String";
                case "float":
                    return "System.Single";
                case "double":
                    return "System.Double";
                case "anyURI":
                    return "System.String";     // Drop namespace qualifier to solve MF-CLR type extension namespace inconsistencies
                case "QName":
                    return "System.String";   // Until MF-CLR supports XmlQualifiedName
                case "normalizedString":
                    return "System.String";
                case "token":
                    return "System.String";
                case "language":
                    return "System.String";
                case "Name":
                    return "System.String";
                case "NCName":
                    return "System.String";
                case "ID":
                    return "System.String";
                case "IDREF":
                    return "System.String";
                case "IDREFS":
                    return "System.String";
                case "ENTITY":
                    return "System.String";
                case "ENTITIES":
                    return "System.String";
                case "NMTOKEN":
                    return "System.String";
                case "NMTOKENS":
                    return "System.String";
                case "decimal":
                    return "System.String"; // Until tht MF-CLR supports deciaml
                case "nonPositiveInteger":
                    return "System.Int64";
                case "negativeInteger":
                    return "System.Int64";
                case "long":
                    return "System.Int64";
                case "int":
                    return "System.Int32";
                case "short":
                    return "System.Int16";
                case "sbyte":
                    return "System.SByte";
                case "byte":
                    return "System.SByte";
                case "nonNegativeInteger":
                    return "System.Int64";
                case "unsignedLong":
                    return "System.UInt64";
                case "unsignedInt":
                    return "System.UInt32";
                case "unsignedShort":
                    return "System.UInt16";
                case "unsignedByte":
                    return "System.Byte";
                case "positiveInteger":
                    return "System.Int64";
                case "System.String":
                    return "System.String";
            }
            return null;
        }

        /// <summary>
        /// Maps an xml schema type to a .net Clr type.
        /// </summary>
        /// <param name="xmlType">An XmlSchema code type.</param>
        /// <returns>A string containing the mapped Clr type or null if a mapping does not exists.</returns>
        /// <remarks>
        /// This method maps schema types to clr types according to the wcf datacontract speficications.
        /// If a type is not supported by the .net micro clr is is mapped to a clr string type.
        /// </remarks>
        internal static string GetClrType(XmlTypeCode xmlType)
        {
            string typeName = "System.";
            switch (xmlType)
            {
                case XmlTypeCode.AnyUri:
                    return typeName + "String";
                case XmlTypeCode.Base64Binary:
                    return typeName + "Byte[]";
                case XmlTypeCode.Boolean:
                    return typeName + "Boolean";
                case XmlTypeCode.Byte:
                    return typeName + "SByte";
                case XmlTypeCode.DateTime:
                    return typeName + "DateTime";
                case XmlTypeCode.Date:
                    return typeName + "DateTime";
                case XmlTypeCode.Decimal:
                    return typeName + "String"; // Until the MF-CLR supports decimal
                case XmlTypeCode.Double:
                    return typeName + "Double";
                case XmlTypeCode.Duration:
                    return typeName + "TimeSpan";
                case XmlTypeCode.Entity:
                    return typeName + "String";
                case XmlTypeCode.Float:
                    return typeName + "Single";
                case XmlTypeCode.GDay:
                    return typeName + "DateTime";
                case XmlTypeCode.HexBinary:
                    return typeName + "Byte";
                case XmlTypeCode.Id:
                    return typeName + "String";
                case XmlTypeCode.Idref:
                    return typeName + "String";
                case XmlTypeCode.Int:
                    return typeName + "Int32";
                case XmlTypeCode.Integer:
                    return typeName + "String"; // Unti the MF-CLR does not support decimal
                case XmlTypeCode.Language:
                    return typeName + "String";
                case XmlTypeCode.Long:
                    return typeName + "Int64";
                case XmlTypeCode.GMonthDay:
                    return typeName + "DateTime";
                case XmlTypeCode.Name:
                    return typeName + "String";
                case XmlTypeCode.NCName:
                    return typeName + "String";
                case XmlTypeCode.NegativeInteger:
                    return typeName + "String"; // Until the MF-CLR supports decimal
                case XmlTypeCode.NmToken:
                    return typeName + "String";
                case XmlTypeCode.NonNegativeInteger:
                    return typeName + "String"; // Until the MF-CLR supports decimal
                case XmlTypeCode.NonPositiveInteger:
                    return typeName + "String"; // Until the MF-CLR supports decimal
                case XmlTypeCode.NormalizedString:
                    return typeName + "String";
                case XmlTypeCode.Notation:
                    return typeName + "String";
                case XmlTypeCode.PositiveInteger:
                    return typeName + "String"; // Until the MF-CLR supports decimal
                case XmlTypeCode.QName:
                    return typeName + "String";
                case XmlTypeCode.Short:
                    return typeName + "Int16";
                case XmlTypeCode.String:
                    return typeName + "String";
                case XmlTypeCode.Time:
                    return typeName + "DateTime";
                case XmlTypeCode.Token:
                    return typeName + "String";
                case XmlTypeCode.UnsignedByte:
                    return typeName + "Byte";
                case XmlTypeCode.UnsignedInt:
                    return typeName + "Int32";
                case XmlTypeCode.UnsignedLong:
                    return typeName + "Int64";
                case XmlTypeCode.UnsignedShort:
                    return typeName + "Int16";
                case XmlTypeCode.DayTimeDuration:
                    return typeName + "TimeSpan";
                case XmlTypeCode.YearMonthDuration:
                    return typeName + "TimeSpan";
                case XmlTypeCode.UntypedAtomic:
                    return typeName + "String";
                case XmlTypeCode.AnyAtomicType:
                    return "object";
            }
            return null;
        }

        /// <summary>
        /// Iterates a CodeTypeMemberCollection and returns an array of indexes
        /// to members that are marked with the IsAttribute custom attribute.
        /// </summary>
        /// <param name="typeMembers">A CodeTypeMemberCollection containing contract members.</param>
        /// <returns>A integer array containing the indexes of attribute type members.</returns>
        /// <remarks>
        /// Special provisiong are made to handle AnyAttribute. If an AnyAttr data member is found,
        /// the index will be moved to the end of the attribute list. This way attribute processing
        /// can occur before an the next data member element is read.
        /// </remarks>
        internal static int[] GetListOfAttributes(CodeTypeMemberCollection typeMembers)
        {
            int[] tempList = new int[typeMembers.Count];
            int index = 0;
            int anyAttribIndex = -1;

            // Add attribute members
            for (int i = 0; i < typeMembers.Count; ++i)
            {
                if (GetCustomAttributeArgumentValue("IsAttribute", typeMembers[i].CustomAttributes) != null)
                    tempList[index++] = i;
                else if (typeMembers[i].Name == "AnyAttr")
                    anyAttribIndex = i;
            }

            int[] sortOrder;
            if (anyAttribIndex == -1)
            {
                sortOrder = new int[index];
                Array.Copy(tempList, sortOrder, index);
            }
            else
            {
                sortOrder = new int[index + 1];
                Array.Copy(tempList, sortOrder, index);
                sortOrder[index] = anyAttribIndex;
            }
            return sortOrder;
        }

        /// <summary>
        /// Iterates a CodeTypeMemberCollection and returns an array of indexes
        /// to members that are not marked with the IsAttribute custom attribute.
        /// </summary>
        /// <param name="typeMembers">A CodeTypeMemberCollection containing contract members.</param>
        /// <returns>A integer array containing the indexes of none attribute type members.</returns>
        /// <remarks>Skip AnyAttr data member because it is moved to the attribute processing order.</remarks>
        internal static int[] GetListOfMembers(CodeTypeMemberCollection typeMembers)
        {
            int[] tempList = new int[typeMembers.Count];
            int index = 0;

            // Add members
            for (int i = 0; i < typeMembers.Count; ++i)
            {
                if (GetCustomAttributeArgumentValue("IsAttribute", typeMembers[i].CustomAttributes) == null)
                    if (typeMembers[i].Name != "AnyAttr")
                        tempList[index++] = i;
            }

            int[] sortOrder = new int[index];
            Array.Copy(tempList, sortOrder, index);
            return sortOrder;
        }

        /// <summary>
        /// Searcehs a members attributes for the schema wildcard 'namespace' attribute.
        /// </summary>
        /// <param name="codeMember">A contract type member.</param>
        /// <returns>A string containing the value of a wildcard namespace attribute if it exist, else null.</returns>
        internal static string GetWildcardNamespaceType(CodeMemberField codeMember)
        {
            string namespaceValue = null;
            foreach (XmlAttribute attrib in codeMember.CustomAttributes)
                if (attrib.Name == "namespace")
                {
                    namespaceValue = attrib.Value;
                    break;
                }
            return namespaceValue;
        }

        /// <summary>
        /// Maps a .net clr type to an xml schema type.
        /// </summary>
        /// <param name="clrTypeName">A string containing the fully qualified name of an .net clr type.</param>
        /// <returns>A string containing the mapped xml schema type type or null if a mapping does not exists.</returns>
        /// <remarks>
        /// This method maps clr types to xml schema types according to the wcf datacontract speficications.
        /// If a direct mapping does not exist. The .net clr type is mapped to an xml string type.
        /// </remarks>
        internal static string GetXmlType(string clrTypeName)
        {
            switch (clrTypeName)
            {
                case "System.Boolean":
                    return "boolean";
                case "System.String":
                    return "string";
                case "Ws.Services.Xml.WsXmlNode":
                    return "any";
                case "Ws.Services.Xml.WsXmlAttribute":
                    return "anyAttribute";
                case "System.Xml.XmlElement":
                    return "any";
                case "System.Xml.XmlAttribute":
                    return "anyAttribute";
                case "System.Object":
                    return "anyType";
                case "System.TimeSpan":
                    return "duration";
                case "System.DateTime":
                    return "dateTime";
                case "System.Byte":
                    return "base64Binary";
                case "System.Single":
                    return "float";
                case "System.Double":
                    return "double";
                case "anyURI":
                    return "System.Uri";
                case "System.Int64":
                    return "long";
                case "System.Int32":
                    return "int";
                case "System.Int16":
                    return "short";
                case "System.SByte":
                    return "sbyte";
                case "System.Byte[]":
                    return "byte";
                case "System.UInt64":
                    return "unsignedLong";
                case "System.UInt32":
                    return "unsignedInt";
                case "System.UInt16":
                    return "unsignedShort";
            }
            return null;
        }

        /// <summary>
        /// Helper function used to determine if a type name represents a native CLR type.
        /// </summary>
        /// <param name="typeName">A string containing a type name to test.</param>
        /// <returns>True if the type name represents a native CLR type else false.</returns>
        /// <remarks>Hack helpers here to avoid problems using Type.GetType when a CLR types like DateTime are not in the base System.dll.</remarks>
        internal static bool IsClrType(string typeName)
        {
            if (typeName == null)
                return false;
            if (typeName.IndexOf("System.") != 0)
                typeName = "System." + typeName;

            switch (typeName)
            {
                case "System.String":
                    break;
                case "System.Boolean":
                    break;
                case "System.Object":
                    break;
                case "System.TimeSpan":
                    break;
                case "System.DateTime":
                    break;
                case "System.Byte[]":
                    break;
                case "System.Single":
                    break;
                case "System.Double":
                    break;
                case "System.Int64":
                    break;
                case "System.Int32":
                    break;
                case "System.Int16":
                    break;
                case "System.SByte":
                    break;
                case "System.UInt64":
                    break;
                case "System.UInt32":
                    break;
                case "System.UInt16":
                    break;
                case "System.Byte":
                    break;
                default:
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Helper used to determine if a type name is a valid clr type name.
        /// </summary>
        /// <param name="typeName">A string containig the type name to test.</param>
        /// <returns>True if the type name is a valid Clr type name, else false.</returns>
        /// <remarks>
        /// Special type provisions: CodeGen does not resolve namespace types for
        /// objects that are not contained in the System namespace. That means types
        /// outside of the System namespace are generated fully qualified i.e. System.Xml.XmlElement
        /// Since these are extension types added to the MF they cannot be namespace qualified without
        /// including System aliases in the code files.
        /// </remarks>
        internal static bool IsNativeClrType(string typeName)
        {
            if (typeName == "XmlElement" || typeName == "XmlAttribute")
                return true;
            return (typeName.Length > 7 && typeName.Substring(0, 7) == "System.") ? true : false;
        }

        /// <summary>
        /// Iterates a CodeTypeMemberCollection and returns an array of indexes
        /// representing the collection sorted by attributes and then data members.
        /// </summary>
        /// <param name="typeMembers">A CodeTypeMemberCollection containing the contract members to sort.</param>
        /// <returns>A integer array containing the indexes of members sorted by attributes first then data members.</returns>
        internal static int[] SortMemberTypes(CodeTypeMemberCollection typeMembers)
        {
            int[] attribList = GetListOfAttributes(typeMembers);
            int[] memberList = GetListOfMembers(typeMembers);
            int[] sortOrder = new int[typeMembers.Count];
            Array.Copy(attribList, sortOrder, attribList.Length);
            Array.Copy(memberList, 0, sortOrder, attribList.Length, memberList.Length);
            return sortOrder;
        }

        /// <summary>
        /// Helper used to determine if a data contract already exists in a namespace.
        /// </summary>
        /// <param name="codeNs">A CodeNamespace containing the data contracts (classes).</param>
        /// <param name="typeName">A string containing tha name of a type to search for.</param>
        /// <returns>True if the type exists in the namespace, else false.</returns>
        internal static bool TypeExists(CodeNamespace codeNs, string typeName)
        {
            for (int i = 0; i < codeNs.Types.Count; ++i)
            {
                if (codeNs.Types[i].Name == typeName)
                    return true;
            }
            return false;
        }
    }
}
